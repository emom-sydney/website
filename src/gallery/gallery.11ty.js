import s3files from "../_data/s3files.js";
import galleries from "../_data/galleries.js";
import lightbox from "./lightbox.js";
import { getImageThumbnail } from "../_data/imageHelpers.js";


// WARNING this code was generated by CoPilot, and although it seems to work 
// I'll bet an experienced JS coder could run rings around it. 
// I'm not though - so for now it is what it is. :)

// Image file extensions that should be rendered as lightbox galleries
const IMAGE_EXTENSIONS = new Set(['jpg', 'jpeg', 'png', 'gif']); 

// Build a nested tree node
const makeNode = () => ({ files: [], children: new Map() });

// Helper: sanitize part for URL path (keep letters, numbers, - and _)
const safePart = (s) => String(s).trim().replace(/[^a-zA-Z0-9-_]+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');

// Helper: compute thumbnail path from image URL (matches imageHelpers.js slugifyFromGallery logic)
function getThumbnailPath(imageUrl, context) {
  if (!imageUrl) return null;
  try {
    const idx = String(imageUrl).indexOf("/gallery");
    const part = idx !== -1 ? String(imageUrl).slice(idx) : String(imageUrl);
    let s = part.replace(/^[\/]+/, "").replace(/\//g, "-").toLowerCase();
    s = s.replace(/[^a-z0-9\-_]+/g, "-");
    s = s.replace(/-+/g, "-").replace(/^-|-$/g, "");
    if (s.length > 180) s = s.slice(0, 180);
    const slugBase = s || `image-${context}`;
    return `/assets/img/th/${slugBase}-250.jpeg`;
  } catch (e) {
    return null;
  }
}

export const data = async () => {
  // Build pages array: each page corresponds to one node (root or subfolder)
  const pages = [];

  // summary for top-level index
  const galleriesSummary = [];

  for (const gallery of galleries) {
    const files = await s3files(gallery);

    // create summary entry (safe gallery name used in URLs)
    const safeGallery = gallery.replace(/\/+$/, '').replace(/\//g, '-').replace(/-+$/, '');
    const galleryUrl = `/gallery/${safeGallery}/index.html`;
    galleriesSummary.push({ gallery, safeGallery, url: galleryUrl });

    // Escape gallery for prefix regex
    const escGallery = gallery.replace(/[-\\/\\^$*+?.()|[\]{}]/g, "\\$&");
    const prefixRe = new RegExp(`^gallery/${escGallery}/?`);

    // Build tree: place each file in the node that corresponds to its immediate folder
    const root = makeNode();
    for (const file of files) {
      const relPath = file.key.replace(prefixRe, "");
      if (!relPath) continue;
      const parts = relPath.split("/").filter(Boolean);

      if (parts.length === 1) {
        // file is directly in the gallery root
        root.files.push(file);
      } else {
        // put the file into the node representing its immediate parent folder
        let node = root;
        for (let i = 0; i < parts.length - 1; i++) {
          const part = parts[i];
          if (!node.children.has(part)) node.children.set(part, makeNode());
          node = node.children.get(part);
        }
        node.files.push(file);
      }
    }

    // Traverse tree to emit a page entry for every node (root + each subfolder)
    function traverse(node, pathParts = []) {
      const safeParts = pathParts.map(p => safePart(p));
      const folderPath = safeParts.length ? `${safeParts.join('/')}/` : '';
      const permalink = `gallery/${safeGallery}/${folderPath}index.html`.replace(/\/{2,}/g, '/');

      // immediate children names only
      const children = Array.from(node.children.keys());

      pages.push({
        gallery,
        safeGallery,
        pathParts: [...pathParts], // original folder names (human readable)
        files: node.files,         // files directly in this folder only
        children,                  // immediate child folder names
        permalink
      });

      // Emit a separate page for each child folder
      for (const [childName, childNode] of node.children) {
        traverse(childNode, [...pathParts, childName]);
      }
    }

    traverse(root, []);
  }

  // Add top-level gallery index page (lists all galleries)
  pages.unshift({
    topIndex: true,
    galleries: galleriesSummary,
    permalink: "gallery/index.html"
  });

  return {
    layout: "main.njk",
    pagination: {
      data: "pages",
      size: 1,
      alias: "page"
    },
    // ensure each paginated item controls its own output path
    permalink: data => data.page.permalink,
    pages
  };
};

export default async function render(data) {
  const page = data.page;

  // Top-level /gallery/index.html -> list of galleries
  if (page.topIndex) {
    const list = (page.galleries || []).map(g => `<li><a href="${g.url}">${g.gallery}</a></li>`).join("");
    return `<h2>Event Galleries</h2>\n<ul>\n${list}\n</ul>\n`;
  }

  // folder page rendering (gallery or subfolder)
  const { gallery, safeGallery, pathParts = [], files = [], children = [] } = page;

  // human readable heading
  const heading = pathParts.length ? pathParts[pathParts.length - 1] : gallery;

  // Try to find the event for this gallery (only for root gallery pages, not subfolders)
  let eventArtists = [];
  if (!pathParts.length && data.events && data.performances && data.artists) {
    // Find event by GalleryURL matching gallery name
    for (const event of data.events) {
      if (event.GalleryURL && event.GalleryURL === gallery) {
        // Found matching event, now get all artists who performed
        for (const perf of data.performances) {
          if (perf.EventID === event.ID) {
            const artist = data.artists.find(a => a.ID === perf.ArtistID);
            if (artist) {
              eventArtists.push(artist);
            }
          }
        }
        break;
      }
    }
    // Sort artists by stage name
    eventArtists.sort((a, b) => String(a.stageName).localeCompare(String(b.stageName)));
  }

  // Build breadcrumb trail:
  // - "Galleries" -> /gallery/index.html
  // - gallery -> /gallery/<safeGallery>/index.html
  // - then each subfolder level
  const crumbs = [];
  crumbs.push({ name: "Galleries", url: "/gallery/index.html" });
  crumbs.push({ name: gallery, url: `/gallery/${safeGallery}/index.html` });

  const safeAcc = [];
  for (let i = 0; i < (pathParts || []).length; i++) {
    const part = pathParts[i];
    safeAcc.push(safePart(part));
    const url = `/gallery/${safeGallery}/${safeAcc.join('/')}/index.html`;
    crumbs.push({ name: part, url });
  }

  // Render breadcrumbs: all but the last are links, last is plain text
  const bcHtml = crumbs.map((c, idx) => {
    const isLast = idx === crumbs.length - 1;
    return isLast ? `<span>${c.name}</span>` : `<a href="${c.url}">${c.name}</a>`;
  }).join(' &gt; ');

  let html = `<p class="breadcrumbs">${bcHtml}</p>\n`;
  html += `<h2>Gallery: ${heading}</h2>\n`;

  // If this is a root gallery page and there are artists, list them
  if (!pathParts.length && eventArtists.length) {
    html += `<h3>Artists</h3>\n<ul class="event-artists">\n`;
    for (const artist of eventArtists) {
      const slug = String(artist.stageName)
        .toLowerCase()
        .trim()
        .replace(/[^\w\s-]/g, '')
        .replace(/[\s_]+/g, '-')
        .replace(/^-+|-+$/g, '');
      html += `<li><a href="/artists/${slug}/index.html">${artist.stageName}</a></li>\n`;
    }
    html += `</ul>\n`;
  }

  // Sort files into video, images, and other.
  const VIDEO_EXTENSIONS = new Set(['mp4', 'mov', 'mkv', 'avi', 'webm', 'flv', 'wmv', 'm4v']);
  const imageFiles = (files || []).filter(f => IMAGE_EXTENSIONS.has(f.ext));
  const nonImageFiles = (files || []).filter(f => !IMAGE_EXTENSIONS.has(f.ext));
  const videoFiles = (nonImageFiles || []).filter(f => VIDEO_EXTENSIONS.has(String(f.ext).toLowerCase()));
  const otherFiles = (nonImageFiles || []).filter(f => !VIDEO_EXTENSIONS.has(String(f.ext).toLowerCase()));

  // If there are image files, render lightbox gallery
  if (imageFiles.length) {
    // Generate thumbnails: check if they exist, create if needed
    const thumbPaths = await Promise.all(
      imageFiles.map(async (f) => {
        // First try the computed path
        const computedPath = getThumbnailPath(f.url, gallery);
        // Try to generate the actual thumbnail (will return existing or create new)
        try {
          const actualPath = await getImageThumbnail(f.url, gallery);
          return actualPath || computedPath;
        } catch (e) {
          // If generation fails, fall back to computed path
          return computedPath;
        }
      })
    );

    const lightboxData = {
      imgPath: imageFiles.map(f => f.url),
      thumbPath: thumbPaths,
      caption: imageFiles.map(f => `${f.name} (${f.sizeFormatted})`)
    };
    html += "<h3>Images</h3>\n";
    html += lightbox(lightboxData);
  }


  // List video files
  if (videoFiles && videoFiles.length) {
    html += `<h3>Video Files</h3>\n<ul class="galleryList">\n`;
    html += videoFiles.map(f => `
      <li>
        ${f.icon || ""} <a href="${f.url}">${f.name}</a>${f.sizeFormatted ? ` (${f.sizeFormatted})` : ""}
      </li>
    `).join("");
    html += `\n</ul>\n`;
  }

  // Then list any remaining non-video files
  if (otherFiles && otherFiles.length) {
    html += `<h3>Other Files</h3>\n<ul class="galleryList">\n`;
    html += otherFiles.map(f => `
      <li>
        ${f.icon || ""} <a href="${f.url}">${f.name}</a>${f.sizeFormatted ? ` (${f.sizeFormatted})` : ""}
      </li>
    `).join("");
    html += `\n</ul>\n`;
  } else if (!imageFiles.length && !videoFiles.length && !otherFiles.length) {
    html += `<p>No files in this folder.</p>\n`;
  }

  // Then: links to immediate child folders (each child has its own index.html page)
  if (children && children.length) {
    html += `<h3>Subfolders</h3>\n<ul>\n`;
    for (const child of children) {
      const parts = [...pathParts, child];
      const safeParts = parts.map(p => safePart(p));
      const childUrl = `/gallery/${safeGallery}/${safeParts.join('/')}/index.html`;
      html += `<li><a href="${childUrl}">${child}</a></li>\n`;
    }
    html += `</ul>\n`;
  }

  return html;
}